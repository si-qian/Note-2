# 正则表达归纳
正则表达式（Regular Expression）是处理字符串的强力工具，是每一位编程人员必备的技能。最初，我在《python编程快速上手》中了解RE，学习 shell 时再次温习。作为初学者，我感到困惑，正则表达语法并不是一致的，而语言解释器在处理字符串时也会进行转义，编写程序时，需用""框住RE，否则你就得麻烦地进行二次转义。
正则表达的介绍不再赘述，我在这里归纳了 POSIX 标准的语法。POSIX 曾经扩充过 RE，因此分为 BRE(Base) 和 ERE(Extended)。

## POSIX-ERE
处理字符串，就是用一些符号来表示一类字符串，比如 [[:upper:]] 表示一个大写字母。我们很自然地想到，字符串本身能够匹配自己，'apple' 匹配 'apple'，'[[:upper:]]' 匹配 '[[:upper:]]'，每一个字母和位置都对应，这是字符串本身地原义。而另用来表示字符模式的符号称作元字符，如 [] 。常见的元字符如 \\ 表示转义，\\n 匹配一个换行符。
### 原义字符
字符串的字面意义，即打印出的样子，键盘上的大多数符号a-z，A-Z，0-9，？*&%￥#@！都能够打印出来。
### 元字符
表示其他字符的字符，经过组合后能匹配一种字符模式。
> **^** 锚点，^(apple) 表示文本行的开头是 apple，但是放在[]内部开头表示否定，如 \[^ab\] 匹配 ab 以外的元素
>
> **$** 锚点， (apple)$ 表示文本行的结尾是 apple
>
> **.** 任意字符，用来匹配任意一个字符 ，包括空格
>
> **[ ]** 字符集，[abc] 表示 abc 中任意一个，[a-z] 表示 abcd...xyz 这 26 个字符中任一个，[[:upper:]] 表示一个大写字母，[[:digit:]] 表示一个数字，[[:alnum:]] 表示一个数字或者字母
>
> **\-**  范围，另外 \- 位于首位时，如 [-ab] ，只表示原义，匹配 -ab三者之一
>
> **{}** 指定数目，a{3} 表示匹配 aaa，a{n-m} 表示匹配 n 至 m 个 a，a{n,} 匹配至少 n 个 a
>
> **?**  限定符，匹配 0 或 1 个，表示“使前面的元素可有可无”，ab? 匹配 a 或者 ab
>
> **\*** 限定符（常被称作通配符），匹配 0 或 多个，a* 表示 0 个 a 或者任意多个 a
>
> **\+** 限定符，匹配 1 个或多个，表示它前面的元素至少出现一次，a\+ 匹配至少一个 a 
>
> **()** 表示优先权
>
> **|** 表示交替，AAA|BBB|CCC 表示匹配 AAA BBB CCC AAABBB BBBCCC AAABBBCCC 甚至CCCBBB
>
> CCCAAABBB
>
> **\\** 转义字符，将字符转义，\\\\ 表示\\ ，\\* 表示 *，\\n 表示换行
## POSIX-BRE

元字符包括:
**^   \$   .   []   *   \\**
其余所有字符被认为是原义字符。但是，字符 ( ) 和 { } 用反斜杠转义后，被看作是元字符。
在 ERE 中，任意元字符前加反斜杠，将导致其被视为一个文本字符。这两者的差异值得注意。

## Tips

在许多编程语言中，解释器本身会使用含有特殊功能的字符，比如Shell中 { } 表示展开，* 表示通配符。

为了避免二次转义，在使用正则表达式时，往往用’ ‘括住。

如 shell 中 grep 命令 

```shell
grep -E '\([0-9]{3-5}\)' text.txt
```

原意匹配被括住的3-5个数字，将’ ‘去掉后，shell会解释为（[0-9]{3-5})，传递给grep，将只匹配 3-5 个数字，不匹配（）。

